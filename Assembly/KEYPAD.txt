///////////////        KEYPAD      ///////////////
///////////////////////////                   PUSHING THE REGISTERS        //////////////////////////////////////////    
xkeypad:SUB R6,R6,R6  
SW R0,R6
//PUSHING RO IN THE RAM (R6=0) 
ADDI R6,R6,01 
SW R1,R6 
//PUSHING R1 IN THE RAM (R6=1)
ADDI R6,R6,01  
SW R2,R6 
//PUSHING R2 IN THE RAM (R6=2)
ADDI R6,R6,01  
SW R3,R6 
//PUSHING R3 IN THE RAM (R6=3)
ADDI R6,R6,01  
SW R4,R6 
//PUSHING R4 IN THE RAM (R6=4)
ADDI R6,R6,01  
SW R5,R6 
//PUSHING R5 IN THE RAM (R6=5)
//////////               CHECK READFLAG             //////////////////
xcheckflag:SUB R6,R6,R6
ADDI R6,R6,09//R6=9
LW R0,R6
SUB R1,R1,R1
BEQ R1,R0,02
J xstartofdecoding
///////////// SPECIFY WHICH STATE SHOUID ENTER /////////
SUB R6,R6,R6
ADDI R6,R6,31
ADDI R6,R6,20//R6=51
LW R0,R6 //R0=STATE
SUB R1,R1,R1
BNE R1,R0,01
J xstartofstate0 ///STATE0
SUB R1,R1,R1
ADDI R1,R1,01
BNE R1,R0,01
J xstartofstate1 //STATE1
SUB R1,R1,R1
ADDI R1,R1,02
BNE R1,R0,01
J xstartofstate2 //STATE2
SUB R1,R1,R1
ADDI R1,R1,03
BNE R1,R0,01
J xstartofstate3 //STATE3
SUB R6,R6,R6
ADDI R6,R6,31
ADDI R6,R6,20//R6=51
SUB R1,R1,R1
SW R1,R6     //FALSE STATE THEN STORE 0 TO STATE
J xcheckflag
////////////   STATE0     ///////////////
xstartofstate0:SUB R4,R4,R4  
ADDI R4,R4,15  //BTL3 ONES 3LA KOL EL ROWS
SLL R4,R4
SLL R4,R4
SLL R4,R4 
SLL R4,R4
SLL R4,R4
SLL R4,R4
SLL R4,R4
SLL R4,R4
SLL R4,R4
SLL R4,R4
SLL R4,R4
SLL R4,R4
OUT R4
IN R3 //INPUT FROM COLUMNS TO SEE IF THERE IS ANY ONE ONE ANY OF THEM 
SUB R5,R5,R5
BNE R3,R5,06// IF R5!=R3 MEANS  KEY IS PRESSED
SUB R6,R6,R6
ADDI R6,R6,31
ADDI R6,R6,20 //R6=51
SUB R0,R0,R0
SW R0,R6///  STATE=0
J xendofstate0
SUB R2,R2,R2 //  PUT IN THE ROW COUNTER FIRST ROW 
SUB R4,R4,R4  //  BTA2KD EN EL REG B ZERO FE EL AWL
ADDI R4,R4,01  //BTL3 ONE 3LA AWL ROW
//SLL AS WE WANT IT TO BE IN THE 4 MOST SIGNIFICANT BITS//
SLL R4,R4
SLL R4,R4
SLL R4,R4 
SLL R4,R4
SLL R4,R4
SLL R4,R4
SLL R4,R4
SLL R4,R4
SLL R4,R4
SLL R4,R4
SLL R4,R4
SLL R4,R4
OUT R4
IN R3 //INPUT FROM COLUMNS TO SEE IF THERE IS ANY ONE ONE ANY OF THEM
SUB R5,R5,R5
BEQ R3,R5,20// IF R5=R3 MEANS NO KEY IS PRESSED IN THIS ROW ,THEN BRANCH
// ROW IS FOUND//
SUB R6,R6,R6
ADDI R6,R6,31   //R6=31
ADDI R6,R6,21   //R6=52
SW R4,R6      ///STORE ROW_SCAN_BYTE
SUB R6,R6,R6
ADDI R6,R6,31  //R6=31
ADDI R6,R6,22   //R6=53
SW R3,R6     // STORE COL_SCAN_BYTE 
SUB R0,R0,R0
ADDI R0,R0,01/// R0=1
SUB R6,R6,R6
ADDI R6,R6,31  //R6=31
ADDI R6,R6,20   //R6=51
SW R0,R6   //STATE=01
SUB R6,R6,R6
ADDI R6,R6,31   //R6=31
ADDI R6,R6,23   //R6=54
SW R2,R6 //STORE ROW_NUM
J xendofstate0 
ADDI R2,R2,01
SLL R4,R4
OUT R4
IN R3 //INPUT FROM COLUMNS TO SEE IF THERE IS ANY ONE ONE ANY OF THEM
SUB R5,R5,R5
BEQ R3,R5,20// IF R5=R3 MEANS NO KEY IS PRESSED IN THIS ROW ,THEN BRANCH
// ROW IS FOUND//
SUB R6,R6,R6
ADDI R6,R6,31   //R6=31
ADDI R6,R6,21   //R6=52
SW R4,R6      ///STORE ROE_SCAN_BYTE
SUB R6,R6,R6
ADDI R6,R6,31  //R6=31
ADDI R6,R6,22   //R6=53
SW R3,R6     // STORE COL_SCAN_BYTE 
SUB R0,R0,R0
ADDI R0,R0,01/// R0=1
SUB R6,R6,R6
ADDI R6,R6,31  //R6=31
ADDI R6,R6,20   //R6=51
SW R0,R6   //STATE=01
SUB R6,R6,R6
ADDI R6,R6,31   //R6=31
ADDI R6,R6,23   //R6=54
SW R2,R6 //STORE ROW_NUM
J xendofstate0 
ADDI R2,R2,01
SLL R4,R4
OUT R4
IN R3 //INPUT FROM COLUMNS TO SEE IF THERE IS ANY ONE ONE ANY OF THEM
SUB R5,R5,R5
BEQ R3,R5,20// IF R5=R3 MEANS NO KEY IS PRESSED IN THIS ROW ,THEN BRANCH
// ROW IS FOUND//
SUB R6,R6,R6
ADDI R6,R6,31   //R6=31
ADDI R6,R6,21   //R6=52
SW R4,R6      ///STORE ROE_SCAN_BYTE
SUB R6,R6,R6
ADDI R6,R6,31  //R6=31
ADDI R6,R6,22   //R6=53
SW R3,R6     // STORE COL_SCAN_BYTE 
SUB R0,R0,R0
ADDI R0,R0,01/// R0=1
SUB R6,R6,R6
ADDI R6,R6,31  //R6=31
ADDI R6,R6,20   //R6=51
SW R0,R6   //STATE=01
SUB R6,R6,R6
ADDI R6,R6,31   //R6=31
ADDI R6,R6,23   //R6=54
SW R2,R6 //STORE ROW_NUM
J xendofstate0 
ADDI R2,R2,01
SLL R4,R4
OUT R4
IN R3 //INPUT FROM COLUMNS TO SEE IF THERE IS ANY ONE ONE ANY OF THEM
SUB R5,R5,R5
BEQ R3,R5,19// IF R5=R3 MEANS NO KEY IS PRESSED IN THIS ROW ,THEN BRANCH
// ROW IS FOUND//
SUB R6,R6,R6
ADDI R6,R6,31   //R6=31
ADDI R6,R6,21   //R6=52
SW R4,R6      ///STORE ROW_SCAN_BYTE
SUB R6,R6,R6
ADDI R6,R6,31  //R6=31
ADDI R6,R6,22   //R6=53
SW R3,R6     // STORE COL_SCAN_BYTE 
SUB R0,R0,R0
ADDI R0,R0,01/// R0=1
SUB R6,R6,R6
ADDI R6,R6,31  //R6=31
ADDI R6,R6,20   //R6=51
SW R0,R6   //STATE=01
SUB R6,R6,R6
ADDI R6,R6,31   //R6=31
ADDI R6,R6,23   //R6=54
SW R2,R6 //STORE ROW_NUM
xendofstate0:J xcheckflag
/////////                 STATE 1           /////////
/////////////     DELAY   ////////////
SUB R0,R0,R0
ADDI R0,R0,15//R0=000F
SLL R1,R0
SLL R1,R1
SLL R1,R1
SLL R1,R1///R1=00F0
OR R0,R0,R1//R0=00FF
SLL R1,R0
SLL R1,R1
SLL R1,R1
SLL R1,R1
SLL R1,R1
SLL R1,R1
SLL R1,R1
SLL R1,R1///R1=FF00
OR R0,R0,R1//R0=FFFF
ADDI R1,R0,00 //R1=FFFF
SUB R2,R2,R2
ADDI R2,R2,04 //R2=04
SUB R4,R4,R4
ADDI R4,R4,01///R4=1
xloop:SUB R3,R3,R3//R3=0
BEQ R0,R3,02
SUB R0,R0,R4///R0--
J xloop
BEQ R2,R3,04
ADD R0,R0,R1///R0=FFFF  AGAIN
SUB R2,R2,R4//R2--
J xloop
///////  GETTING ROW_SCAN_BYTE & COL_SCAN_BYTE  //////////
xstartofstate1:SUB R6,R6,R6
ADDI R6,R6,31  ///R6=31
ADDI R6,R6,21  // R6=52
LW R0,R6    /// R0=ROW_SCAN_BYTE
SUB R6,R6,R6
ADDI R6,R6,31  //R6=31
ADDI R6,R6,22    //R6=53
LW R1,R6   /// R1=COL_SCAN_BYTE                             
/////////                     CHECKING THE KEY IF STILL PRESSED OR HAS BEEN RELEASED           ///////
OUT R0
IN R3
///  WE WILL SEE IF R3(INPUT OF MIPS)  EQUAL COL_SCAN_BYTE TO MAKE SURE SAME KEY IS STILL PRESSED ///
BEQ R1,R3,07 //IF R1=R3 THEN KEY IS STILL PRESSED THEN BRANCH
/// KEY IS RELEASED ///
SUB R6,R6,R6
ADDI R6,R6,31 //R6=31
ADDI R6,R6,20 //R6=51
SUB R4,R4,R4 
SW R4,R6  ///STATE=0
J xendofstate1
///KEY IS PRESSED//
SUB R6,R6,R6
ADDI R6,R6,31 //R6=31
ADDI R6,R6,20 //R6=51
SUB R4,R4,R4
ADDI R4,R4,02 
SW R4,R6  ///STATE=2
SUB R5,R5,R5
ADDI R5,R5,08
BNE R5,R1,07
SUB R6,R6,R6
ADDI R6,R6,31 //R6=31
ADDI R6,R6,24 //R6=55
SUB R4,R4,R4
ADDI R4,R4,00
SW R4,R6 //COL_NUM=0
J xcalculatethekey
SRL R5,R5
BNE R5,R1,07
SUB R6,R6,R6
ADDI R6,R6,31 //R6=31
ADDI R6,R6,24 //R6=55
SUB R4,R4,R4
ADDI R4,R4,01
SW R4,R6 //COL_NUM=1
J xcalculatethekey
SRL R5,R5
BNE R5,R1,07
SUB R6,R6,R6
ADDI R6,R6,31 //R6=31
ADDI R6,R6,24 //R6=55
SUB R4,R4,R4
ADDI R4,R4,02
SW R4,R6 //COL_NUM=2
J xcalculatethekey
SRL R5,R5
BNE R5,R1,06
SUB R6,R6,R6
ADDI R6,R6,31 //R6=31
ADDI R6,R6,24 //R6=55
SUB R4,R4,R4
ADDI R4,R4,03
SW R4,R6 //COL_NUM=3
xcalculatethekey:SUB R6,R6,R6
ADDI R6,R6,31
ADDI R6,R6,23////R6=54
LW R5,R6///R5=ROW_NUM
SLL R0,R5
SLL R0,R0
ADD R0,R0,R4
ADDI R0,R0,01//R0=PRESSED_KEY
SUB R6,R6,R6
ADDI R6,R6,31
ADDI R6,R6,25//R6=56
SW R0,R6 
SUB R6,R6,R6
ADDI R6,R6,09 ////R6=09
SUB R0,R0,R0
ADDI R0,R0,01
SW R0,R6 ////READFLAG=01
xendofstate1:J xcheckflag 
/////////                 STATE 2            /////////
///////  GETTING ROW_SCAN_BYTE & COL_SCAN_BYTE  //////////
xstartofstate2:SUB R6,R6,R6
ADDI R6,R6,31  ///R6=31
ADDI R6,R6,21  // R6=52
LW R0,R6    /// R0=ROW_SCAN_BYTE
SUB R6,R6,R6
ADDI R6,R6,31  //R6=31
ADDI R6,R6,22    //R6=53
LW R1,R6   /// R1=COL_SCAN_BYTE
/////////                     CHECKING THE KEY IF STILL PRESSED OR HAS BEEN RELEASED           ///////
OUT R0
IN R3
///  WE WILL SEE IF R3(INPUT OF MIPS)  EQUAL COL_SCAN_BYTE TO MAKE SURE SAME KEY IS STILL PRESSED ///
BEQ R1,R3,08 //IF R1=R3 THEN KEY IS STILL PRESSED THEN BRANCH
/// KEY IS RELEASED ///
SUB R6,R6,R6
ADDI R6,R6,31 //R6=31
ADDI R6,R6,20 //R6=51
SUB R4,R4,R4
ADDI R4,R4,03 
SW R4,R6  ///STATE=3
J xendofstate2
///KEY IS STILL PRESSED//
SUB R6,R6,R6
ADDI R6,R6,31 //R6=31
ADDI R6,R6,20 //R6=51
SUB R4,R4,R4
ADDI R4,R4,02 
SW R4,R6  ///STATE=2
SUB R6,R6,R6
ADDI R6,R6,09///R6=9
SUB R0,R0,R0
ADDI R0,R0,01
SW R0,R6 ///READFLAG=1
xendofstate2:J xcheckflag
/////////////       state 3    /////////// 
/////////////     DELAY   ////////////
SUB R0,R0,R0
ADDI R0,R0,15//R0=000F
SLL R1,R0
SLL R1,R1
SLL R1,R1
SLL R1,R1///R1=00F0
OR R0,R0,R1//R0=00FF
SLL R1,R0
SLL R1,R1
SLL R1,R1
SLL R1,R1
SLL R1,R1
SLL R1,R1
SLL R1,R1
SLL R1,R1///R1=FF00
OR R0,R0,R1//R0=FFFF
ADDI R1,R0,00 //R1=FFFF
SUB R2,R2,R2
ADDI R2,R2,04 //R2=04
SUB R4,R4,R4
ADDI R4,R4,01///R4=1
xloop:SUB R3,R3,R3//R3=0
BEQ R0,R3,02
SUB R0,R0,R4///R0--
J xloop
BEQ R2,R3,04
ADD R0,R0,R1///R0=FFFF  AGAIN
SUB R2,R2,R4//R2--
J xloop
//getting the row scan byte 
xstartofstate3:SUB R6,R6,R6  //ADD 0 IN R6 
ADDI R6,R6,31  // R6=31 
ADDI R6,R6,21 // R6=52 
LW R0,R6 // R0 = ROW SCAN BYTE 
//getting the COL scan byte 
SUB R6,R6,R6  //ADD 0 IN R6 
ADDI R6,R6,31  // R6=31 
ADDI R6,R6,22 // R6=53 
LW R1,R6 // R1 = COL SCAN BYTE
OUT R0 // Out the row scan byte 
IN R3 
BEQ R1,R3,06   // IF EQUAL THEN THE KEY IS STILL PRESSED AND WE BACK TO STATE 2 IF NOT EQUAL THEN THE KEY IS RELEASED SO WE BACK TO STATE 0 
SUB R6,R6,R6
ADDI R6,R6,31 
ADDI R6,R6,20  // R6 = 51 Which is address of the state 
SUB R4,R4,R4
SW R4,R6 // STATE =0
J xendofstate3 
SUB R6,R6,R6
ADDI R6,R6,31 
ADDI R6,R6,20
SUB R4,R4,R4
ADDI R4,R4,02
SW R4,R6 // STATE =2  
xendofstate3:J xcheckflag
/////////////// ENCODING THE PRESSED KEY /////////////
xstartofdecoding:SUB R6,R6,R6
ADDI R6,R6,31
ADDI R6,R6,25//R6=56
LW R0,R6///R0=KEY_PRESSED
SUB R6,R6,R6
ADDI R6,R6,08//R6=08
SUB R1,R1,R1
ADDI R1,R1,01///R1=0001 
SUB R2,R2,R2
ADDI R2,R2,01//R2=DECODE KEY
BNE R0,R2,02
SW R1,R6///DECODING=0001
J xendofkeypad
SLL R1,R1 ///R1=0002
SUB R2,R2,R2
ADDI R2,R2,02//R2=DECODE KEY
BNE R0,R2,02
SW R1,R6///DECODING=0002
J xendofkeypad
SLL R1,R1 ///R1=0004
SUB R2,R2,R2
ADDI R2,R2,03//R2=DECODE KEY
BNE R0,R2,02
SW R1,R6///DECODING=0004
J xendofkeypad
SLL R1,R1 ///R1=0008
SUB R2,R2,R2
ADDI R2,R2,05//R2=DECODE KEY
BNE R0,R2,02
SW R1,R6///DECODING=0008
J xendofkeypad
SLL R1,R1 ///R1=0010
SUB R2,R2,R2
ADDI R2,R2,06//R2=DECODE KEY
BNE R0,R2,02
SW R1,R6///DECODING=0010
J xendofkeypad
SLL R1,R1 ///R1=0020
SUB R2,R2,R2
ADDI R2,R2,07//R2=DECODE KEY
BNE R0,R2,02
SW R1,R6///DECODING=0020
J xendofkeypad
SLL R1,R1 ///R1=0040
SUB R2,R2,R2
ADDI R2,R2,09//R2=DECODE KEY
BNE R0,R2,02
SW R1,R6///DECODING=0040
J xendofkeypad
SLL R1,R1 ///R1=0080
SUB R2,R2,R2
ADDI R2,R2,10//R2=DECODE KEY
BNE R0,R2,02
SW R1,R6///DECODING=0080
J xendofkeypad
SLL R1,R1 ///R1=0100
SUB R2,R2,R2
ADDI R2,R2,11//R2=DECODE KEY
BNE R0,R2,02
SW R1,R6///DECODING=0100
J xendofkeypad
SLL R1,R1 ///R1=0200
SUB R2,R2,R2
ADDI R2,R2,14//R2=DECODE KEY
BNE R0,R2,02
SW R1,R6///DECODING=0200
J xendofkeypad
SLL R1,R1 ///R1=0400
SUB R2,R2,R2
ADDI R2,R2,04//R2=DECODE KEY
BNE R0,R2,02
SW R1,R6///DECODING=0400
J xendofkeypad
SLL R1,R1 ///R1=0800
SLL R1,R1///R1=1000
SLL R1,R1///R1=2000
SLL R1,R1///R1=4000
SLL R1,R1///R1=8000
SUB R2,R2,R2
ADDI R2,R2,15//R2=DECODE KEY
BNE R0,R2,02
SW R1,R6///DECODING=0001
J xendofkeypad
SUB R6,R6,R6
ADDI R6,R6,09
SUB R3,R3,R3
SW R3,R6///RF=0
J xcheckflag
///////////////////////////                   POPING THE REGISTERS        //////////////////////////////////////////    
xendofkeypad:SUB R6,R6,R6  
LW R0,R6
//POPING RO IN THE RAM (R6=0) 
ADDI R6,R6,01 
LW R1,R6 
//POPING R1 IN THE RAM (R6=1)
ADDI R6,R6,01  
LW R2,R6 
//POPING R2 IN THE RAM (R6=2)
ADDI R6,R6,01  
LW R3,R6 
//POPING R3 IN THE RAM (R6=3)
ADDI R6,R6,01  
LW R4,R6 
//POPING R4 IN THE RAM (R6=4)
ADDI R6,R6,01  
LW R5,R6 
//POPING R5 IN THE RAM (R6=5)


